# Sconfig
import numpy as np
import pandas as pd
from ase.io import read
from ase.neighborlist import NeighborList
from collections import Counter
import re
from typing import Dict, List, Tuple

class SconfigCalculator:
    def __init__(self, cutoff_radius=3.0):
        """
        cutoff_radius: 配位阳离子环境半径范围(Å)
        """
        self.cutoff_radius = cutoff_radius
 
    def read_poscar(self, poscar_path: str):
        """
        读取POSCAR文件
        """
        try:
            self.structure = read(poscar_path)
            print(f"成功读取结构: {len(self.structure)} 个原子")
            print(f"晶胞参数: {self.structure.cell.lengths()}")
 
            # 获取元素组成
            elements = self.structure.get_chemical_symbols()
            element_counts = Counter(elements)
            print("元素组成:", dict(element_counts))
 
            return True
        except Exception as e:
            print(f"读取POSCAR文件失败: {e}")
            return False
 
    def classify_cation_sites(self) -> Dict[str, List[int]]:
        """
        不同配位环境的阳离子位点
        """
        # 识别阳离子和阴离子
        cations = []
        anions = []
 
        for i, atom in enumerate(self.structure):
            if atom.symbol in ['Li', 'Mg', 'Ca', 'Ni', 'Cu', 'Zn', 'Al', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Y', 'Nb','Zr', 'Mo', 'Ru', 'Sn','W', 'Te', 'Pt', 'Sb', 'Hf', 'Rh', 'Sb', 'La', 'Lu', 'Ir', 'Ge', 'Rh', 'Pd', 'Ta', 'Bi', 'Sc','Sr', 'Ba']:
                cations.append(i)
            elif atom.symbol == 'O':
                anions.append(i)
 
        print(f"发现 {len(cations)} 个阳离子位点")
 
        # 阳离子配位环境
        cutoff = [self.cutoff_radius] * len(self.structure)
        nl = NeighborList(cutoff, self_interaction=False, bothways=True)
        nl.update(self.structure)
 
        site_classes = {}
 
        for cation_idx in cations:
            cation_symbol = self.structure[cation_idx].symbol
 
            # 配位环境
            indices, offsets = nl.get_neighbors(cation_idx)
            coordination_env = []
 
            for neighbor_idx in indices:
                neighbor_symbol = self.structure[neighbor_idx].symbol
                if neighbor_symbol == 'O':  # 氧配位
                    distance = self.structure.get_distance(cation_idx, neighbor_idx)
                    coordination_env.append((neighbor_symbol, distance))
 
            # 根据配位数和平均键长分类
            coord_number = len(coordination_env)
            if coord_number > 0:
                avg_distance = np.mean([d for _, d in coordination_env])
 
                # 定义配位类型
                if coord_number == 6:  # 八面体配位
                    if avg_distance < 2.5:
                        site_type = f"{cation_symbol}_Octa_Short"
                    else:
                        site_type = f"{cation_symbol}_Octa_Normal"
                elif coord_number == 4:  # 四面体配位
                    site_type = f"{cation_symbol}_Tetra"
                else:
                    site_type = f"{cation_symbol}_Coord{coord_number}"
            else:
                site_type = f"{cation_symbol}_Isolated"
 
            if site_type not in site_classes:
                site_classes[site_type] = []
            site_classes[site_type].append(cation_idx)
 
        print("阳离子位点分类结果:")
        for site_type, indices in site_classes.items():
            print(f"  {site_type}: {len(indices)} 个位点")
 
        return site_classes
 
    def calculate_compositional_entropy(self, site_type: str) -> float:
        """
        计算特定位点类型的构型熵
        Returns:
            Sconfig值 (J/mol·K)
        """
        R = 8.314  # 理想气体常数 J/mol·K
 
        # 解析元素组成
        elements = re.findall(r'([A-Z][a-z]*)', site_type.split('_')[0])
 
        if len(elements) == 1:
            # 单一元素位点，熵为0
            return 0.0
 
        # 计算位点中不同元素的摩尔分数
        site_indices = self.site_classes[site_type]
        element_counts = Counter()
 
        for idx in site_indices:
            symbol = self.structure[idx].symbol
            element_counts[symbol] += 1
 
        total_sites = len(site_indices)
        entropy = 0.0
 
        for count in element_counts.values():
            x_i = count / total_sites
            if x_i > 0:
                entropy -= x_i * np.log(x_i)
 
        sconfig = R * entropy
        return sconfig
 
    def analyze_transition_metal_layer(self) -> Dict[str, float]:
        """
        专门分析过渡金属层的构型熵)
        Returns:
            各TM层区域的Sconfig值
        """
        tm_elements = ['Mg', 'Ca', 'Ni', 'Cu', 'Zn', 'Al', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Y', 'Nb','Zr', 'Mo', 'Ru', 'Sn','W', 'Te', 'Pt', 'Sb', 'Hf', 'Rh', 'Sb', 'La', 'Lu', 'Ir', 'Ge', 'Rh', 'Pd', 'Ta', 'Bi', 'Sc','Sr', 'Ba']
        tm_positions = []
 
        for i, atom in enumerate(self.structure):
            if atom.symbol in tm_elements:
                # 获取层状结构的z坐标
                pos = atom.position
                tm_positions.append((i, pos[2], atom.symbol))
 
        if not tm_positions:
            return {"Overall": 0.0}
 
        # 按z坐标分层
        z_coords = [pos[1] for _, pos, _ in tm_positions]
        z_min, z_max = min(z_coords), max(z_coords)
 
        # 定义层（假设等间距分为3层）
        n_layers = 3
        layer_height = (z_max - z_min) / n_layers
 
        layer_compositions = {f"Layer_{i}": Counter() for i in range(n_layers)}
 
        for idx, z, symbol in tm_positions:
            layer_idx = int((z - z_min) / layer_height)
            if layer_idx == n_layers:  # 处理边界情况
                layer_idx = n_layers - 1
            layer_compositions[f"Layer_{layer_idx}"][symbol] += 1
 
        # 计算每层的Sconfig
        layer_entropies = {}
 
        for layer_name, composition in layer_compositions.items():
            total = sum(composition.values())
            if total == 0:
                layer_entropies[layer_name] = 0.0
                continue
 
            entropy = 0.0
            for count in composition.values():
                x_i = count / total
                if x_i > 0:
                    entropy -= x_i * np.log(x_i)
 
            layer_entropies[layer_name] = 8.314 * entropy
 
        return layer_entropies
 
    def calculate_overall_sconfig(self) -> Dict[str, float]:
        """
        计算总体和分区域的Sconfig值
        """
        results = {}
 
        # 总体TM元素的Sconfig
        tm_elements = ['Mg', 'Ca', 'Ni', 'Cu', 'Zn', 'Al', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Y', 'Nb','Zr', 'Mo', 'Ru', 'Sn','W', 'Te', 'Pt', 'Sb', 'Hf', 'Rh', 'Sb', 'La', 'Lu', 'Ir', 'Ge', 'Rh', 'Pd', 'Ta', 'Bi', 'Sc','Sr', 'Ba']
        tm_counts = Counter()
 
        for atom in self.structure:
            if atom.symbol in tm_elements:
                tm_counts[atom.symbol] += 1
 
        total_tm = sum(tm_counts.values())
        if total_tm > 0:
            entropy = 0.0
            for count in tm_counts.values():
                x_i = count / total_tm
                if x_i > 0:
                    entropy -= x_i * np.log(x_i)
            results["Overall_TM_Sconfig"] = 8.314 * entropy
 
        # 各配位环境的Sconfig
        for site_type in self.site_classes:
            if len(self.site_classes[site_type]) > 1:  # 需要多个位点才能计算熵
                sconfig = self.calculate_compositional_entropy(site_type)
                results[f"Sconfig_{site_type}"] = sconfig
 
        # TM层分析
        layer_results = self.analyze_transition_metal_layer()
        results.update(layer_results)
 
        return results
 
